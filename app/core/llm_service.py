from langchain_core.prompts import ChatPromptTemplate
from langchain_openai import ChatOpenAI

from app.core.config import Config
from app.core.database_handler import DatabaseHandler
from app.core.logger import get_logger


class LLMService:
    def __init__(self, database_url: str, model_name: str = "gpt-4o-mini"):
        """
        Initialize the LLMService with a database connection and language model.

        :param database_url: The URL of the database to connect to.
        :param model_name: The name of the language model to use. Default is "gpt-4o-mini".
        """
        self.logger = get_logger(self.__class__.__name__)
        self.db_manager = DatabaseHandler(database_url)
        self.llm = ChatOpenAI(model=model_name, openai_api_key=Config.OPENAI_API_KEY)

    def generate_analysis_description(self):
        """
        Generate a concise analysis description based on the database schema.

        :return: A user-friendly description string generated by the LLM.
        """
        schema = self.db_manager.get_schema()
        if not schema:
            self.logger.error(
                "Failed to generate analysis description: Schema is empty."
            )
            raise ValueError(
                "Schema could not be retrieved. Ensure the database is accessible."
            )

        # Template for a more concise, user-friendly description
        prompt_template = ChatPromptTemplate.from_template(
            template=(
                f"You are connected to a database with the following schema:\n{schema}\n"
                "Provide a brief, end-user-friendly description of this database, "
                "such as 'You are connected to the XYZ database, which holds information about ABC.'"
            )
        )

        description_prompt = prompt_template.format()
        response = self.llm.invoke([{"role": "system", "content": description_prompt}])
        self.logger.info("Analysis description generated successfully.")
        return response.content.strip()

    def process_data_analysis(
        self, natural_language_query: str, db_type: str = "SQL Server"
    ):
        """
        Process a natural language query to generate a SQL query, visualizations, and layout suggestions.

        :param natural_language_query: The natural language query from the user.
        :param db_type: The type of database for which the query should be compatible (e.g., SQL Server, PostgreSQL).
        :return: A tuple containing the DataFrame, SQL query, and visualization suggestions.
        """
        schema = self.db_manager.get_schema()
        if not schema:
            self.logger.error("Failed to process data analysis: Schema is empty.")
            raise ValueError(
                "Schema could not be retrieved. Ensure the database is accessible."
            )

        self.logger.info(
            "Processing data analysis for query: %s", natural_language_query
        )

        prompt_template = ChatPromptTemplate.from_template(
            template=(
                f"Based on the following {db_type} schema information:\n{schema}\n"
                f"Generate a SQL query for the given natural language query: '{{query}}'. "
                f"The SQL query must be compatible with {db_type}. Ensure the model never tries to query a table "
                f"that is not present in the provided schema. Additionally, provide specific suggestions for "
                f"visualizations and layout that best represent the data based on this query."
            )
        )

        sql_query_prompt = prompt_template.format(query=natural_language_query)
        response = self.llm.invoke([{"role": "system", "content": sql_query_prompt}])
        response_content = response.content

        sql_query, visualization_suggestions, layout_suggestions = (
            self.extract_query_visualizations_layout(response_content)
        )
        sql_query = self.clean_sql_query(sql_query)

        self.logger.info("Executing SQL query generated from LLM.")
        result_df = self.db_manager.execute_sql(sql_query)

        self.logger.info("Data analysis completed successfully.")
        return result_df, sql_query, visualization_suggestions, layout_suggestions

    def clean_sql_query(self, sql_query: str) -> str:
        """
        Clean the SQL query by removing unnecessary prefixes and keywords.

        :param sql_query: The raw SQL query string.
        :return: The cleaned SQL query string.
        """
        sql_query = sql_query.lstrip().lower().replace("sql\n", "").replace("sql ", "")
        if "LIMIT" in sql_query.upper():
            limit_value = sql_query.split("LIMIT")[1].strip().rstrip(";")
            sql_query = sql_query.split("LIMIT")[0].strip()
            sql_query = sql_query.replace("SELECT", f"SELECT TOP {limit_value}")
        return sql_query.strip()

    def extract_query_visualizations_layout(self, response_content):
        """
        Extract the SQL query, visualization suggestions, and layout suggestions from the LLM response.

        :param response_content: The content returned by the LLM.
        :return: A tuple containing the SQL query, visualization suggestions, and layout suggestions.
        """
        if (
            "SQL Query:" in response_content
            and "Visualization Suggestions:" in response_content
            and "Layout Suggestions:" in response_content
        ):
            sql_query_part = (
                response_content.split("SQL Query:")[1]
                .split("Visualization Suggestions:")[0]
                .strip()
            )
            sql_query = sql_query_part.split("```")[1].strip()

            visualization_suggestions_part = (
                response_content.split("Visualization Suggestions:")[1]
                .split("Layout Suggestions:")[0]
                .strip()
            )
            visualization_suggestions = [
                s.strip()
                for s in visualization_suggestions_part.split("\n")
                if s.strip()
            ]

            layout_suggestions_part = response_content.split("Layout Suggestions:")[
                1
            ].strip()
            layout_suggestions = [
                s.strip() for s in layout_suggestions_part.split("\n") if s.strip()
            ]

        else:
            sql_query = response_content.split("```")[1].strip()
            visualization_suggestions = ["bar"]
            layout_suggestions = []

        return sql_query, visualization_suggestions, layout_suggestions
